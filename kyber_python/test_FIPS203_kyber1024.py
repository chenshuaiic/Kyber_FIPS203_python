
from Crypto.Random import get_random_bytes
from cpake import generate_kyber_keys, encrypt, decrypt
from params import KYBER_512SK_BYTES, KYBER_768SK_BYTES, KYBER_1024SK_BYTES, KYBER_SYM_BYTES, KYBER_SS_BYTES, \
    KYBER_INDCPA_SECRETKEY_BYTES_K512, KYBER_INDCPA_PUBLICKEYBYTES_K512, \
    KYBER_INDCPA_SECRETKEY_BYTES_K768, KYBER_INDCPA_PUBLICKEYBYTES_K768, \
    KYBER_INDCPA_SECRETKEY_BYTES_K1024, KYBER_INDCPA_PUBLICKEYBYTES_K1024
from Crypto.Hash import SHA3_256, SHA3_512, SHAKE256
from util import cast_to_byte
from ccakem import kem_keygen512, kem_encaps512, kem_decaps512, kem_keygen768, kem_encaps768, kem_decaps768, \
    kem_keygen1024, kem_encaps1024, kem_decaps1024
    
def intlist(x):
    y = bytearray.fromhex(x)
    return [ cast_to_byte(i) for i in y]

def cast(x):
    return [ cast_to_byte(i) for i in x]


def kem_keygen1024_fips203(rnd, z):
    """
    generate kyber keys for security level 512
    :input random number rnd(d in fips203) and z
    :return: tuple of (private_key(dk in FIPS203), public key(ek in FIPS203)), each a byte array
    :return H_pk only for test your own implementation
    """
    
    params_k = 4
    sk_, pk = generate_kyber_keys(params_k,rnd)

    md = SHA3_256.new()
    md.update(bytearray([x & 0xFF for x in pk]))
    H_pk = md.digest()
    H_pk = [ cast_to_byte(x) for x in H_pk ]
    pkh = [0 for x in range(0, len(H_pk))]
    for i in range(0, len(H_pk)):
        pkh[i] = H_pk[i]

    z = [ cast_to_byte(x) for x in z]

    sk = sk_[:] + pk[:] + H_pk[:] + z[:]

    return (sk, pk, H_pk)


def kem_encaps1024_fips203(pubkey, m):
    """
    enc for security level 512
    : input public key(ek in FIPS203) and message(m in FIPS203)
    :return: tuple of (shared secret(K in FIPS203) and cipher(c in FIPS203)), each a byte array
    """

    params_k = 4

    m = [ cast_to_byte(x) for x in m ]

    md = SHA3_256.new()
    md.update(bytearray([x & 0xFF for x in pubkey]))
    Hpk = md.digest()
    Hpk = [ cast_to_byte(x) for x in Hpk ]

    #m = Hm + Hpk
    m = m + Hpk

    md512 = SHA3_512.new()
    md512.update(bytearray([x & 0xFF for x in m]))
    kr = md512.digest()
    kr = [ cast_to_byte(x) for x in kr]
    K = kr[0:KYBER_SYM_BYTES]          # k for fips203
    #print(K)
    r = [ kr[i + KYBER_SYM_BYTES] for i in range(0, len(kr) - KYBER_SYM_BYTES)]
    #c = encrypt(Hm, pubkey, r, params_k)
    c = encrypt(m, pubkey, r, params_k)

    md = SHA3_256.new()
    md.update(bytearray([x & 0xFF for x in c]))
    Hc = md.digest()
    Hc = [ cast_to_byte(x) for x in Hc ]
    KHc = K + Hc

    xof = SHAKE256.new()
    xof.update(bytearray([ x & 0xFF for x in KHc]))
    shared_secret = xof.read(KYBER_SYM_BYTES)
    shared_secret = [ cast_to_byte(x) for x in shared_secret]
    return K, c


def kem_decaps1024_fips203(private_key, ciphertext):
    """

    :param private_key(dk in FIPS203):
    :param ciphertext(c in FIPS203):
    :return: (shared_secret(K in FIPS203))
    """
    params_k = 4
    sk = private_key[0: KYBER_INDCPA_SECRETKEY_BYTES_K1024]
    pk = private_key[KYBER_INDCPA_SECRETKEY_BYTES_K1024:KYBER_INDCPA_SECRETKEY_BYTES_K1024+KYBER_INDCPA_PUBLICKEYBYTES_K1024]
    z = private_key[KYBER_1024SK_BYTES - KYBER_SYM_BYTES:]
    h = private_key[KYBER_1024SK_BYTES - 2 * KYBER_SYM_BYTES:KYBER_1024SK_BYTES - KYBER_SYM_BYTES]
    m_ = decrypt(ciphertext, sk, params_k)   #m'=K-PKE.Decrypt(dkpke,c)

    md512 = SHA3_512.new()
    md512.update(bytearray([ x & 0xFF for x in (m_[:] + h[:])]))
    K_r_ = md512.digest()    #(k',r') = G(m'||h)
    
    K_r_ = [ cast_to_byte(x) for x in K_r_ ]
    K_ = K_r_[0:KYBER_SYM_BYTES]  #k'
    r_ = K_r_[-KYBER_SYM_BYTES:]    #r'
    
    zc = z + ciphertext
    
    cmp = encrypt(m_, pk, r_, params_k)
    
    if(cmp == ciphertext):
        sharedSecretFixedLength = K_
        print("decaps correct")
    else:
        temp_buf = z[:] + ciphertext   
        xof = SHAKE256.new()
        xof.update(bytearray([ x & 0xFF for x in tmp_buf]))
        sharedSecretFixedLength = xof.read(KYBER_SS_BYTES)
        sharedSecretFixedLength = [cast_to_byte(x) for x in sharedSecretFixedLength]
    
    return sharedSecretFixedLength



############### test key generation of kyber512 ##############################

rnd = "7c9935a0b07694aa0c6d10e4db6b1add2fd81a25ccb148032dcd739936737f2d"  # the random number d that used in my verilog implementation (in hex)
rnd = bytearray.fromhex(rnd)  # trans. rnd into the form that the python model can use

z = "8626ed79d451140800e03b59b956f8210e556067407d13dc90fa9e8b872bfb8f"# the random number z that used in my verilog implementation
z = bytearray.fromhex(z)

h_verilog = "8a39e87d531f3527c207edcc1db7faddcf9628391879b335c707839a0db051a8"

#h_verilog = "7ffad1bc8af73b7e874956b81c2a2ef0bfabe8dc93d77b2fbc9e0c64efa01e84" # the H(ek) that generated by my verilog implementation
h_test = intlist(h_verilog) # trans. h_verilog into the form that the python model used

priv, pub, h = kem_keygen1024_fips203(rnd,z)  # key generation based on the input data
print("h(ek) generated by python model=",h)
print("h(ek) generated by verilog=",h_test)
assert(h == h_test)


############## test kem-encapsulation of kyber512 ############################### 
m=  "147c03f7a5bebba406c8fae1874d7f13c80efe79a3a9a874cc09fe76f6997615"# the message m that used in my verilog implementation
m = bytearray.fromhex(m)


k_verilog = "63a1039074f01f2651213ad9350d6561cb03a60400e74118bb4464d87b9db205"
#k_verilog = "c608777086ed9ffdf92cd4f1c999aedd0b42e5e8ef6732f4111246481e260463"# the shared secret K that generated by my verilog implementation
k_test = intlist(k_verilog)

# c generated by my verilog implementation
c_test="b15696acabf3f5c71c09605df350f98ef9897474f241c7f7d16f7a69604358508458916d2c8552c704cb6e0da4305a11720a2b59a6d8190fc3e389e6551e7c59578fe2b05d7591bab326d894e23656c6b5fe4b7abd6505a8c26d1df8b44a0ed53affff9a585fce86da3b3ff22b1fdae2f6d255c26535f61694d50471f1d84d17673e481f4e824c82810ce8f2ecc9bb3f5f07bf1430e7bfd99fb98f3d2f941edf642d7b9e73bc1595a04cd949fa766468489f402f92325f6d9ec5d696e0fac2c6a37983a6451384ce9d9de448f15874e530943e8e0fe29960587a89b8052c9d0e6b0ea5dbb734d2a9c05cbb6d0c79f4a57db5afded6a7df0ecf47b7a31deaf37dfa1dc89722a47b40b4a50c7a2f32e8ab3da973aa683c0a698294ca3a045483175d87786b47f78ab0295b8267edfeeda442c351a38e95cf43b08342c67d0bc5dd5974f6c5c003ea31b5804a311c29eba17bdb547a629ec83974043bd03a37d0ec7ff39de1dfb8e632a86b26021e753e7dc731bc4ed7e7fece78b07dff5e8775b2223e19dfb3a06a1865ed4f08a84544492504f2962e005fde5de6e4ff48994d4ff811ce31e3909803c3534c1c6c6ddc9e1a43c845e7e7e2a1081186bede4b5bcf1b80b13d218a4ab446f479e38c1de4a594e0f20cdc23a9ea58778cb2fb104f1dc91ba5c17e74004c430aab1a3d1679daeb5082e517af6a4e28f564441b73235d084a5831cbb394cecd997fe08b1b4aa995bdd9726c04615859fffd1c9906fb2d0401ed6f591e13c6e79ec5e862079e6dfd3ca688fa5ac7f8d27907530549ac71fdeb5f869d2a9b235a0e54b3b866021d6b5c98d1c6c0c00489995e3c3496b69c76338ac422c9f94158ed5cf9cc6be93846034d4ba533a3422c29d675405ae853b8497dc912f4a83500c89db76bcdd7046d9832fa3d2bf3d02465ebb4168035118f087ddd47643d2db71f47419aed973ec4384866d45e1df216eda5bf6133f84a328c1129621ec1501fc46fe3eda460680b397a42a4368eb3dc88451b2b616eec5f1ec05e5bd2084b4945d20ea8630d81492c78cf06a78ec508a0c5713b486021643266a60d99744678e598b152cf1829897af720c18eb6893d8b1f81c8bbc55c8047391a9051a6d0d65471891ac2dfd8ac984aa7aff3974492b751fdc5dea1396886e8c94b9448e1ee633f6c2143552eb849c6d7e72b6a7c8121461544515e346d69973111c924acda06470b5df2320e06b8f1aff413f9e888436c31378025be66726a0ba559177b1137c431cce1a6fb00de36c6afce92f11bc75a885fbbd9b108e6ead43fee47da311230f922bab93a7677711e97ea4129802c5dff20d0d9db97f882c63379fc27d08a6fecc288cc06e257654b388e5018801ff19bac2c9487a5f47e073101dd37b10d43c935119b6f70eddf9ba5149ed64e8c129d978cbf2c1a306f83a6347bfc445e8fd645ab0e4b2a939328cb55a7951a3a938a06aed24ef32562149c8b7f2dadd75d2db3782b64f4cb1f56a0945277c9c5e1605a0c0eb65d7fe3421c90874bb9ccb945ea74c997eca73c94059b77c7c3f08dd6e5e494e3f23399f2fce056e9f130feb6cecbb3e8dece49e5673757515742094ac382563857b5d412d7191cdc5de0681c72c5daf833beedcd88e40123a617d2bd0d7595916a6894b9263b6eb91e2380154e0cfc52784258cf7320c4f02ead0b4471ea0dd0abeb5e63628f4836a23db269cee09e46f35b9de87ecb0422ad8ec6cb60b717eec21216f0b791c852a9f8a4c26167d7350e17fa3ec745b46311a671cb8d7f14885ff01bab0ef469d0850fe807e70d36a4b736b2c32c676258ae7d553dcab8ade6368aa23179778add214dd9154f510f50e5560c65fcec35e87882530edc65bee66b25a535da2146e14f8390bcf579c337bad974575d5f09a8768883f9393a144171feb3fc663eeef138b21bd557abbbad2c0224341fabfb6c6fdea6f3c265e5d8af169a964a7a86a1a0e222dd6371382079f838234aea8ff6e2b894e04a9a34cfacab81b0704b14d7d109949c68644c015bc2f26a9c294287ecf152d846f914c0745ceb7ec3d36ad9d723c15f89e2d8fe2c18e11180d0709d7002a50f87d1c73dbb616fd8de30339d83da5a8ed50321cc12f94dff84d9e544f17ec34a60eb414b2878cc1a05c264a066ddd37f0c504f0e6ccd0f311eb5212de32e9d655125e4f4"
#c_test="a413be81047259202401ee35989d25a3856cd1c0260ce2391de323736b678f328005c821ad092180b4496f2129280f4f299404362b9d141948b6bb02acd5736559fc9039018c961dddd94ee559198471d4a049e547b5636cf8bbf7db1a90c72b870923dcd54b148c60c9c8ee604d30eebb6901e6df2596121826058d25029ae399c95f6aacbaafe34f118ddba7a69d7cd899b5f4d58d3df2a889b030ce9a7ea6446d41a60a175f127da94c276baa1edfb357d41b2857ad462c83d8ff00236d9bac59325e0c3bddcb37bfe0fda4e167fcf6aec149fe5f9f6393fc4715c6995d67f2b4ddb0c7678ee140bcfdd2365e8122ca92cbba1ac703357edf15210c6892669f1a2b88d792be7d9aa56c5e8df758abb4bbae83141d2759dfc4ea8f2cf00dd86a7312fbaea9cfe6d7fd3f13fc8cb75d252cb3ec7e7b37cd81d88f38ae593ede6f8a81d51183d7dc7f57abb21ce2c593db72f0bf779cccc82420f53c2fe364b1fd3cd2ec54b924a62afa4c3195578e48aa5f507e7928d7527d6577d3fca87e7b7b19a89f69f0018eeb36871baadfcc7094e344fb36481fb14a5c53c30867cf1c5c02cf6227f9aae8d8a12b24c5ac2b8eb912b87de8325409e440a47b5c74237179a6ce5558ee09101ca4e645e24bdc28778735abf98b0688f6289d503251582aab6e81ced0179829f7311731d0615d0a0d955978aafbf8aa440a5c85870c58b3e5c1ff9267f094b742f516e8e9759d0f88021d99a7fd65bbee801217276656d21f3734de0a5589b33fe996ecb99c0d8a52d54b39dcfe707fc11e35638a69d908ccb0edacfb2aa435e3beb981d3fdef59cade6f63cda056c526cdc55b87a3ef2638bcaeedf406711053a09d310699dc8e3d07acc10e1ea8ec8d51ab31c04ca88c2177a51193b418ccc4b2548ecda861598ffaa8b16eaf89d59c8403c39c8d94c428cf19180e1420287b455fb6e4e5bfbd383aef18ca99f810f6cea703be4b9bf0cb6f0c5383e83ed3a723a27d8e3991067656726925b20fb735b12752facf684e5c03dc5be7a63af4bd930754fdb5f749306c2cfa6e398925c346d9d572924b153b7673b7a5022140264fd5a0abe00b5d85c686f296fbc49dd3155ad2f748255506909b355c7060dded4dd2fa21c7bf681251e7d63289e15f85854a25b4fb085ef03a03cd050f4f5021d112f3291a9fd60ad01e0b5797e78d9b94befe9746d754e6ce41da34c57da3d7deda6b233082c4137614e964fff0e38472e36e495f54e2d2371a7581b694cb263ddf80bdd43f6383578b5e18244a69cac9cdabea3d05718f5c23b1d4ce6684457597d01284b38b9d3eb1eba4f5beff990bb749f096a30f1bde724ade3789de5ef183a60163e28f1584500984ca5153555c38c61649683a727921ffcce3007c267783bddbdb9de48880c4e8452dab29e7c4f8d1d5dfd303a908b1ce08be0b9fae98894dcb2692d0b32fa39da98bd4ff0ea10f0b438a4971a7fc47182fbe52d6de71fee3e824a39f19c27f51aec6d92bc7f8b8f071847bca"
#c_test="7549998d469e2e479002305b09b44dbadbc2457ffd3125f6d31b0f27b803d581071c1dc6181196fe76df78de20dda609cf1b7cb7a352c4dd9c2cfc18801f036fe40f8f7e6f3dd73f387130be387b1713418f83d93dc7f8074a032455c46f857c6b6b35429c790065420d742252ee53f53f6e64a9b78a49bc29b8ce84831a01c3429e346960dc559526d97853c36631b4773285fafe8e3ca4255a8723ae4f02ddd85a4781b9f4186d67a83b5d9eddc3ae7cd4096c33f4d97fe02030ecb6a1a8ad9b19d3eb32f1b8f271b30353e9e19dd183f06b54c3cb02ef166282752aa11c8158e48bbc6830171ca7ddb75a35e46c35321abe6a742032c772a16b3d1cddfc6f2801e2b817302dbc94f333c0cb91e1cebd5ec61e49fa5a14aaa393755fc3e6f4b8c5c4fa4baa07a08c4f3394626358a15e690ee1e4829b111c17241aee37d5c832f4847688fe5b5d1b19e8e04d9d1937001987f3b4b83549c3e530e4119d164b20ef9d3a72f74c044a974591228b41e680ec5640a97234c2c6017c95e91be2bd498547d57a5222b8162a3546656d59980d51af595bf5f23a632f6d8544b81074aed34c0352ba560deafb07441a55a9376342e50a0ec2537228255a4b5d03c92957f4ea3507b4baadce53ccdfb7364ffc1817b58c50ef28e322e1b945e0eb9b1233975c30a5545368682714bf502b61e1d0457a9753e10de0f1bf35ec3a3f470a3c69ccb04d2d98fab3a0b6729a9875e1db533c96b41e3d98628a6f8cf668406c5f038e6b7b242fdf86a7f1e697aeb136114167b13f89f231bcec7a4166b39eab4a3709237822050c49c92595a237f2eb483b9e1dd6124bed5eb9b7b5121296376b7d2014a77560ca65833d8beb4d6ae68efd7a11acc7de87d82be1ad573ae9f6f0766fd786387d1a8c12d1c8a296b4f72634f70577688848e576851f13be48df335d4acd89793a6c6c0655fc39bc9e1e27b4a500f708cd4a9f2ec672ba5bf8ad23998d4c0c958f290f2a6c4e6cd8c0cdc85f5716ec98a4c8995d378cc6e2a1e8b82800ddf03b3226a2e7817771e509b4955ee2bed4217bdf0630b5840f2524ab"
c_test = intlist(c_test)

K_for_fips203, cipher = kem_encaps1024_fips203(pub,m) # encaps.
print("k for fips203 generated by python=",K_for_fips203)
print("k generated by verilog=",k_test)
assert(K_for_fips203 == k_test)

print("c_test generated my verilog=",c_test)
print("cipher or fips203 generated by python model=",cipher)
assert(c_test == cipher)

############ test kem-decaps of kyber512  #####################################
#k_verilog = "c608777086ed9ffdf92cd4f1c999aedd0b42e5e8ef6732f4111246481e260463"# the shared secret K that generated by my verilog implementation
k_verilog = "63a1039074f01f2651213ad9350d6561cb03a60400e74118bb4464d87b9db205"

k_test = intlist(k_verilog)

#print("priv=",priv)

K_ = kem_decaps1024_fips203(priv,cipher)
print("k' generated by decaps of python model=",K_)
assert(K_for_fips203 == K_)










